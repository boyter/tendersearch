// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package database

import (
	"context"
)

const tenderCount = `-- name: TenderCount :one
SELECT count(*) FROM tender
WHERE deleted = 0
    LIMIT 1
`

func (q *Queries) TenderCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, tenderCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const tenderCreate = `-- name: TenderCreate :one
INSERT INTO tender (uuid, created_at, updated_at, source, link, title, unix_date, categories, description, guid, json_version, json, attempt, error, publish_at, closing_at)
VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    returning uid, uuid, created_at, updated_at, source, link, title, unix_date, categories, description, guid, json_version, json, attempt, error, publish_at, closing_at, deleted
`

type TenderCreateParams struct {
	Uuid        string
	CreatedAt   int64
	UpdatedAt   int64
	Source      string
	Link        string
	Title       string
	UnixDate    int64
	Categories  string
	Description string
	Guid        string
	JsonVersion string
	Json        string
	Attempt     int64
	Error       string
	PublishAt   int64
	ClosingAt   int64
}

func (q *Queries) TenderCreate(ctx context.Context, arg TenderCreateParams) (Tender, error) {
	row := q.db.QueryRowContext(ctx, tenderCreate,
		arg.Uuid,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Source,
		arg.Link,
		arg.Title,
		arg.UnixDate,
		arg.Categories,
		arg.Description,
		arg.Guid,
		arg.JsonVersion,
		arg.Json,
		arg.Attempt,
		arg.Error,
		arg.PublishAt,
		arg.ClosingAt,
	)
	var i Tender
	err := row.Scan(
		&i.Uid,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Source,
		&i.Link,
		&i.Title,
		&i.UnixDate,
		&i.Categories,
		&i.Description,
		&i.Guid,
		&i.JsonVersion,
		&i.Json,
		&i.Attempt,
		&i.Error,
		&i.PublishAt,
		&i.ClosingAt,
		&i.Deleted,
	)
	return i, err
}

const tenderExistsByLink = `-- name: TenderExistsByLink :one
SELECT COUNT(*)
FROM tender
WHERE link = ?
`

func (q *Queries) TenderExistsByLink(ctx context.Context, link string) (int64, error) {
	row := q.db.QueryRowContext(ctx, tenderExistsByLink, link)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const tenderGetByLink = `-- name: TenderGetByLink :one
SELECT uid, uuid, created_at, updated_at, source, link, title, unix_date, categories, description, guid, json_version, json, attempt, error, publish_at, closing_at, deleted
FROM tender
WHERE link = ?
`

func (q *Queries) TenderGetByLink(ctx context.Context, link string) (Tender, error) {
	row := q.db.QueryRowContext(ctx, tenderGetByLink, link)
	var i Tender
	err := row.Scan(
		&i.Uid,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Source,
		&i.Link,
		&i.Title,
		&i.UnixDate,
		&i.Categories,
		&i.Description,
		&i.Guid,
		&i.JsonVersion,
		&i.Json,
		&i.Attempt,
		&i.Error,
		&i.PublishAt,
		&i.ClosingAt,
		&i.Deleted,
	)
	return i, err
}

const tenderGetByUuid = `-- name: TenderGetByUuid :one
SELECT uid, uuid, created_at, updated_at, source, link, title, unix_date, categories, description, guid, json_version, json, attempt, error, publish_at, closing_at, deleted
FROM tender
WHERE uuid = ?
`

func (q *Queries) TenderGetByUuid(ctx context.Context, uuid string) (Tender, error) {
	row := q.db.QueryRowContext(ctx, tenderGetByUuid, uuid)
	var i Tender
	err := row.Scan(
		&i.Uid,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Source,
		&i.Link,
		&i.Title,
		&i.UnixDate,
		&i.Categories,
		&i.Description,
		&i.Guid,
		&i.JsonVersion,
		&i.Json,
		&i.Attempt,
		&i.Error,
		&i.PublishAt,
		&i.ClosingAt,
		&i.Deleted,
	)
	return i, err
}

const tenderListAll = `-- name: TenderListAll :many
SELECT uid, uuid, created_at, updated_at, source, link, title, unix_date, categories, description, guid, json_version, json, attempt, error, publish_at, closing_at, deleted
FROM tender
WHERE deleted = 0
ORDER BY closing_at DESC
`

func (q *Queries) TenderListAll(ctx context.Context) ([]Tender, error) {
	rows, err := q.db.QueryContext(ctx, tenderListAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tender
	for rows.Next() {
		var i Tender
		if err := rows.Scan(
			&i.Uid,
			&i.Uuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Source,
			&i.Link,
			&i.Title,
			&i.UnixDate,
			&i.Categories,
			&i.Description,
			&i.Guid,
			&i.JsonVersion,
			&i.Json,
			&i.Attempt,
			&i.Error,
			&i.PublishAt,
			&i.ClosingAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tenderListSearchable = `-- name: TenderListSearchable :many
SELECT uid, uuid, created_at, updated_at, source, link, title, unix_date, categories, description, guid, json_version, json, attempt, error, publish_at, closing_at, deleted
FROM tender
WHERE deleted = 0
  AND closing_at > ?
ORDER BY closing_at ASC
`

func (q *Queries) TenderListSearchable(ctx context.Context, closingAt int64) ([]Tender, error) {
	rows, err := q.db.QueryContext(ctx, tenderListSearchable, closingAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tender
	for rows.Next() {
		var i Tender
		if err := rows.Scan(
			&i.Uid,
			&i.Uuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Source,
			&i.Link,
			&i.Title,
			&i.UnixDate,
			&i.Categories,
			&i.Description,
			&i.Guid,
			&i.JsonVersion,
			&i.Json,
			&i.Attempt,
			&i.Error,
			&i.PublishAt,
			&i.ClosingAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tenderUpdateJson = `-- name: TenderUpdateJson :exec
UPDATE tender SET
                  json_version = ?,
                  json = ?
WHERE uid = ?
`

type TenderUpdateJsonParams struct {
	JsonVersion string
	Json        string
	Uid         int64
}

func (q *Queries) TenderUpdateJson(ctx context.Context, arg TenderUpdateJsonParams) error {
	_, err := q.db.ExecContext(ctx, tenderUpdateJson, arg.JsonVersion, arg.Json, arg.Uid)
	return err
}
